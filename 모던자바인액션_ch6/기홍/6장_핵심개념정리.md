# 🗃️ CHAPTER 6 스트림으로 데이터 수집 (핵심 정리)

---

## 📍 6.1 컬렉터란 무엇인가?

**컬렉터(Collector)** 는 스트림의 요소를 원하는 결과 형태로 모으는 도구다.

* 스트림 API에서 `collect` 연산을 사용해 데이터를 원하는 형식으로 모을 수 있다.
* 자주 쓰이는 컬렉터는 미리 정의되어 있고(`Collectors` 클래스), 직접 정의할 수도 있다.

```java
List<String> names = menu.stream()
                         .map(Dish::getName)
                         .collect(Collectors.toList());
```

### 🔸 고급 리듀싱 기능들 (Advanced Reducing)

* 컬렉터는 복잡한 리듀싱(합계, 평균, 통계, 문자열 연결 등)을 쉽게 처리할 수 있게 설계됐다.

### 🔸 미리 정의된 컬렉터 (Predefined Collectors)

* 자바가 기본으로 제공하는 `Collectors` 클래스:
  * `toList()`, `toSet()`, `toMap()`, `joining()`, `groupingBy()`, `partitioningBy()` 등 다양한 기능 제공

---

## 📍 6.2 리듀싱과 요약

리듀싱(Reducing)은 스트림의 모든 요소를 하나의 결과로 모으는 연산이다.

### 🔸 최댓값과 최솟값 검색

* 스트림의 최대, 최소값은 쉽게 구할 수 있다:

  ```java
  menu.stream().collect(maxBy(Comparator.comparing(Dish::getCalories)));
  ```

### 🔸 요약 연산 (Summarizing)

* `Collectors.summarizingInt()` 같은 메서드를 사용하면 합, 평균, 최대, 최소 등의 통계 정보를 한 번에 구할 수 있다.

### 🔸 문자열 연결 (Joining)

* 스트림 요소를 하나의 문자열로 연결하는 메서드
  ```java
  String joinedNames = menu.stream()
                           .map(Dish::getName)
                           .collect(Collectors.joining(", "));
  ```

### 🔸 범용 리듀싱 연산

* 모든 리듀싱 연산은 아래와 같은 범용 연산으로 구현할 수 있다.
  ```java
  int totalCalories = menu.stream()
                          .collect(reducing(0, Dish::getCalories, Integer::sum));
  ```

---

## 📍 6.3 그룹화(Grouping)

* 스트림의 데이터를 특정 기준으로 그룹화할 수 있다.
* `Collectors.groupingBy()`를 사용한다.

```java
Map<Dish.Type, List<Dish>> dishesByType = menu.stream()
    .collect(groupingBy(Dish::getType));
```

### 🔸 그룹화된 요소 조작

* 그룹화 후 추가적인 연산 가능 (최대값, 요약 등)

### 🔸 다수준 그룹화 (Multi-level grouping)

* 여러 수준으로 그룹화 (그룹 내에서 또 다시 그룹화)

```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeAndCalories =
    menu.stream().collect(
        groupingBy(Dish::getType,
                   groupingBy(dish -> {
                       if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                       else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                       else return CaloricLevel.FAT;
                   }))
    );
```

### 🔸 서브그룹으로 데이터 수집

* 그룹화한 결과를 다시 다른 형태로 수집 가능

---

## 📍 6.4 분할(Partitioning)

그룹화의 특별한 형태로, 조건을 만족하는 그룹과 그렇지 않은 그룹으로 나누는 방식이다.

### 🔸 분할의 장점

* 명확한 true/false 조건으로 두 그룹으로 나눌 때 효율적임

```java
Map<Boolean, List<Dish>> vegetarianDishes =
    menu.stream().collect(partitioningBy(Dish::isVegetarian));
```

### 🔸 숫자를 소수와 비소수로 분할하기

* 소수 판별 알고리즘을 이용한 응용 예제 (자세한 구현은 책 본문 참조)

---

## 📍 6.5 Collector 인터페이스

컬렉터를 직접 정의하려면 `Collector` 인터페이스를 구현한다.

### 🔸 Collector 인터페이스 메서드

* `supplier()`: 결과 컨테이너 생성
* `accumulator()`: 요소를 결과 컨테이너에 누적
* `combiner()`: 병렬 처리 시 컨테이너 병합
* `finisher()`: 결과 컨테이너 최종 변환
* `characteristics()`: 최적화를 위한 특성 제공

---

## 📍 6.6 커스텀 컬렉터 구현 (성능 개선)

직접 컬렉터를 만들어 특정 상황에 성능을 향상시키는 방법을 배운다.

### 🔸 소수로만 나누기 (Prime number Collector)

* 스트림으로부터 소수를 효율적으로 찾는 컬렉터 구현 예시

### 🔸 컬렉터 성능 비교

* 병렬 스트림을 사용할 때, 직접 구현한 컬렉터가 기존 방식보다 얼마나 빠른지 비교해볼 수 있다.

---

## 📍 6.7 마치며

이 장을 통해 스트림의 데이터를 다양한 형태로 수집하고 그룹화하는 방법을 익힌다.

이 개념들을 잘 이해하면:

* 코드가 깔끔하고 명료해짐
* 복잡한 데이터 처리 작업이 쉬워짐
* 코드의 성능을 최적화하는 데 도움됨

---

📖 **책을 읽을 때는 특히 이런 흐름을 유의하면 좋아:**

* 컬렉터의 기본 개념과 리듀싱 개념 이해
* 그룹화와 분할의 차이 이해
* 커스텀 컬렉터를 작성하는 이유와 방법 이해
