### Intro (기존의 `Date` 가 갖고 있던 안좋은 점)

> 2017년 9월 21일을 가리키는 `Date` 인스턴스를 만드는 코드
> 출력 결과: `Thu Sep 21 00:00:00 CET 2017`

```java
Date date = new Date(117, 8, 21);
```

딱 봐도 결과가 직관적이지 않다. 또한 `Date` 클래스에는 toString 으로는 문자열을 추가로 활용하기 어렵다. CET(중앙 유럽 시간) 를 사용하지만, 그렇다고 Date 클래스가 자체적으로 시간대 정보를 알고 있는 것도 아니다.

`Date` 의 대안으로 나온 `Calendar` 도 문제가 많았는데, 년도가 1900 년부터 시작하는 오프셋은 없앴지만, 달의 인덱스는 여전히 0으로 시작했고, DateFormat 같은 일부 기능은 Date 클래스에만 작동했다.

DateFormat 의 경우에도 스레드가 안전하지 않다는 문제가 있었다.

또한 Date 와 Calendar 둘 다 가면 클래스였기 때문에 유지보수가 어려웠다는 문제점도 있었다.

결국 `Joda-Time` 라는 서드파티 라이브러리의 많은 기능을 `java.time` 패키지에 추가했다.

### 12.1 LocalDate, LocalTime, Instant, Duration, Period 클래스

`java.time` 패키지는 LocalDate, LocalTime, LocalDateTime, Instant, Duration, Period 등 새로운 클래스를 제공한다.

#### 12.1.1 LocalDate 와 LocalTime 사용

`LocalDate` 인스턴스는 시간을 제외한 날짜를 표현하는 불변 객체다. **LocalDate 객체는 어떤 시간대 정보도 포함하지 않는다.**

정적 팩토리 메서드 `of` 로 `LocalDate` 인스턴스를 만들 수 있다.

> LocalDate 만들고 값 읽기

```java
LocalDate date	= LocalDate.of(2017, 9, 21);	// 2017-09-21
int year 		= date.getYear();				// 2017
Month month		= date.getMonth();				// SEPTEMBER
int day			= date.getDayOfMonth();			// 21
DayOfWeek dow	= date.getDayOfWeek();			// THURSDAY
int len			= date.lengthOfMonth();			// 30 (9월의 일 수)
boolean leap	= date.isLeapYear();			// false (윤년이 아님)
```

팩토리 메서드 now 는 시스템 시계의 정보를 이용해서 현재 날짜의 정보를 얻는다.

```java
LocalDate today = LocalDate.now();
```

`TemporalField` 는 시간 관련 객체에서 어떤 필드의 값에 접근할지 정의하는 인터페이스다. get 메서드에 `TemporalField` 를 전달해서 정보를 얻는 방법도 있다.

```java
int year = date.get(ChronoField.YEAR);
int month = date.get(ChronoField.MONTH_OF_YEAR);
int day = date.get(ChronoField.DAY_OF_MONTH);
```

내장 메서드를 이용해 가독성을 높일 수 있다.

```java
int year = date.getYear();
int month = date.getMonthValue();
int day = date.getDayOfMonth();
```

시간(`13:45:20` 같은)은 `LocalTime` 클래스로 표현할 수 있다. `of` 메서드는 `시간, 분`, `시간, 분, 초`를 인수 로 받는 두 가지 오버로드 된 메서드를 이용할 수 있다.

```java
LocalTime time = LocalTime.of(13, 14, 25);	// 13:45:20
int hour = time.getHoue();					// 13
int minute = time.getMinute();				// 45
int second = time.getSecond();				// 20
```

날짜와 시간 문자열로 `LocalDate` 와 `LocalTime` 의 인스턴스를 만드는 방법도 있다.

> parse 정적 메서드 사용. parse 메서드에 DateTimeFormatter(DateTimeFormat 를 대체하는 클래스)를 전달할 수도 있다.

```java
LocalDate date = LocalDate.parse("2017-09-21");
LocalTime time = LocalTime.parse("13:45:20");
```

#### 12.1.2 날짜와 시간 조합

`LocalDateTime` 은 `LocalDate` 와 `LocalTime` 을 쌍으로 갖는 복합 클래스다.

```java
// 2017-09-21T13:45:20
LocalDateTime dt1 = LocalDateTime.of(2017, Month.SEPTEMBER, 21, 13, 45, 20);
LocalDateTime dt2 = LocalDateTime.of(date, time);
LocalDateTime dt3 = date.atTime(13.45.20);
LocalDateTime dt4 = date.atTime(time);
LocalDateTime dt5 = time.atDate(date);
```

```java
LocalDate date1 = dt1.toLocalDate(); // 2017-09-21
LocalTime time1 = dt1.toLocalTime(); // 13:45:20
```

#### 12.1.3 Instant 클래스: 기계의 날짜와 시간

Intstant 클래스는 사람이 아닌 기계를 위한 클래스이다. 기계의 관점에서는 연속된 시간에서 특정 지점을 하나의 큰 수로 표현하는 것이 가장 자연스러운 시간 표현 방법이다. Instant 클래스는 유닉스 에포크 시간 (1970.01.01 00:00:00 UTC)을 기준으로 특정 지점까지의 시간을 초로 표현한다.

팩토리 메서드 ofEpochSecond 에 초를 넘겨줘서 Instant 클래스 인스턴스를 만들 수 있다. Instant 클래스는 나노초(10억분의 1초)의 정밀도를 제공한다. 또한 오버로드된 ofEpochSecond 메서드 버전에서는 두 번째 인수를 이용해서 나노초 단위로 시간을 보정할 수 있다. (0 ~ 999,999,999)

```java
Instant.ofEpochSecond(3); // 3초
Instant.ofEpochSecond(3, 0) // 3초 0나노초
Instant.ofEpochSecond(2, 1_000_000_000) // 3초 0나노초

/* 아래 세 팩토리 메서드는 같은 결과를 반환한다. */
Instant.ofEpochSecond(3, 1);
Instant.ofEpochSecond(4, -999_999_999);
Instant.ofEpochSecond(2, 1_000_000_001);
```

#### 12.1.4 Duration과 Period 정의

> Duration: 시, 분, 초, 나노초 단위
> Period: 년, 월, 일 단위

지금까지 살펴본 모든 클래스들은 `Temporal` 인터페이스들을 구현 했다. `Temporal` 인터페이스는 특정 시간을 모델링하는 객체의 값을 어떻게 읽고 조작할지를 정의한다.

`Duration` 클래스: 두 시간 객체 사이의 지속시간. `between` 으로 두 시간 객체 사이의 지속시간을 만들 수 있다.

```java
Duration d1 = Duration.between(time1, time2);			// 2개의 LocalTime
Duration d2 = Duration.between(dateTime1, dateTime2);	// 2개의 LocalDateTime
Duration d3 = Duration.between(instant1, instant2);		// 2개의 Instant
```

`Period` 클래스 또한 between 메서드를 사용하면 두 LocalDate 의 차이를 확인할 수 있다.

```java
Period tenDays = Period.between(LocalDate.of(2017, 9, 11), LocalDate.of(2017, 9, 21));
```

> Duration, Period 의 다양한 팩토리 메서드들

```java
Duration threeMinutes = Duration.ofMinutes(3);
Duration threeMinutes = Duration.of(3, ChronoUnit.MINUTES);

Period tenDays = Period.ofDays(10);
Period threeWeeks = Period.ofWeeks(3);
Period twoYearsSixMonthsOneDay = Period(2, 6, 1);
```

395 페이지 Duration과 Period 클래스가 공통으로 제공하는 메서드 표... 생략

### 12.2 날짜 조정, 파싱, 포매팅

#### 12.2.1 TemporalAdjusters 사용하기

좀 더 복잡한 날짜 조정: TemporalAdjusters 의 with 메서드로 가능

```java
import static java.time.temporal.TemporalAdjusters.*;

LocalDate date1 = LocalDate.of(2014, 3, 18);				// 2014-03-18
LocalDate date2 = date1.with(nextOrSame(DayOfWeek.SUNDAY));	// 2014-03-23
LocalDate date3 = date2.with(lastDayOfMonth());				// 2014-03-31
```

399 페이지의 TemporalAdjusters 의 팩토레 메서드로 만들 수 있는 TemporalAdjuster 리스트... 생략

#### 12.2.2 날짜와 시간 객체 출력과 파싱

포매팅과 파싱 전용 패키지인 `java.time.format` 이 새로 추가되었다. 이 패키지에서 가장 중요한 클래스는 `DateTimeFormatter` 이다. 정적 팩토리 메서드와 상수를 이용해서 손쉽게 포매터를 만들 수 있다.

```java
LocalDate date = LocalDate.of(2014, 3, 18);
String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE); // 20140318
String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE); // 2014-03-18
```

반대로 날짜나 시간을 표시하는 문자열을 파싱해서 날짜 객체를 다시 만들 수 있다.

```java
LocalDate date1 = LocalDate.parse("20140318", DateTimeFormatter.BASIC_ISO_DATE);
LocalDate date2 = LocalDate.parse("2014-03-18", DateTimeFormatter.ISO_LOCAL_DATE);
```

> 예제: 패턴으로 DateTimeFormatter 만들기

```java
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate date1 = LocalDate.of(2014, 3, 18);
String formattedDate = date1.format(formatter);
Local date2 = LocalDate.parse(formattedDate, formatter);
```

> 예제: 지역화된 DateTimeFormatter 만들기

```java
DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern("d. MMMM yyyy", Local.ITALIAN);
LocalDate date1 = LocalDate.of(2014, 3, 18);
String formattedDate = date.format(italianFormatter); // 18. marzo 2014
LocalDate date2 = LocalDate.parse(formattedDate, italianFormatter);
```

> 예제: DateTimeFormatter 만들기 (위 예제와 동일한 결과를 만듦)

```java
DateTimeFormatter italianFormatter = new DateTimeFormatterBuilder()
	.appendText(ChronoField.DAY_OF_MONTH)
	.appendListeral(". ")
	.appendText(ChronoField.MONTH_OF_YEAR)
	.appendLiteral(" ")
	.appendText(ChronoField.YEAR)
	.parseCaseIntensive()
	.toFormatter(Local.ITALIAN);
```

### 12.3 다양한 시간대와 캘린더 활용 방법