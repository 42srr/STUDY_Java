# 1. 자바가 버전 8에서 변한 이유

자바 8의 요구사항

1. 간결한 코드
2. 멀티코어 프로세서의 쉬운 활용 (멀티코어 프로세서의 대중화라는 시대의 흐름)

# 2. 자바 8이 제공하는 것

1. 스트림 API (CPU 병렬 연산 지원)
2. 메서드에 코드를 전달하는 기법 (함수형 프로그래밍 패러다임 적용 가능)
3. 인터페이스의 디폴트 메서드

2와 3은 1(스트림 API) 덕분에 추가됐다.

# 3. 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념

## 3-1. 스트림 처리

> 스트림: 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임. 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

자바 8에서 `java.util.stream` 패키지에 스트림 API 가 추가되었다.

**스트림 API**의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 우리가 하려는 작업을 (DB처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다.

또한 스트림 파이프라인을 이용해 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있어 스레드라는 복잡한 작업을 사용하지 않으면서도 병렬성을 얻을 수 있다.

## 3-2. 동작 파라미터화로 메서드에 코드 전달하기

자바 8에 추가된 두 번재 프로그램 개념은 코드 일부를 API로 전달하는 기능이다. 이러한 기능을 이론적으로 **동작 파라미터화(behavior parameterization)** 라고 부른다.

> C언어에도 함수의 매개변수에 함수 주소를 전달해 해당 함수를 호출하는 기능이 있다.

## 3-2. 병렬성과 공유 가변 데이터

스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔서 병렬성을 얻을 수 있다.

# 4. 자바 함수

자바 8에서는 함수를 **새로운 값의 형식** 으로 추가했다. 이는 후술할 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문이다.

> 일급값(일급 시민) vs 이급값(이급 시민)
>
> 일급값: 자유롭게 전달할 수 있는 값(int, double, 객체의 참조(클래스의 인스턴스), 배열)
>
> 이급값: 전달할 수 없는 값(클래스, 자바 8 이전의 메서드).

**메서드 참조(method reference)**: 메서드를 값으로 사용. 식별자는 `::` 예시) `File::isHidden` <- File 클래스의 isHidden 메서드

- 코드 넘겨주기 예제:
  - `filterApples(inventory, Apple::isGreenApple)` : 초록색 사과만 inventory 리스트에 남긴다
  - `filterApples(inventory, Apple::isHeavyApple)` : 무거운 사과만 inventory 리스트에 남긴다

**람다(익명 함수)**: 일회성으로 사용할 이름이 없는 함수를 값으로 사용할 수 있다. `(int x) -> x + 1`

- 위의 예시 람다 예제:
  - `filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()))` : 초록색 사과만 inventory 리스트에 남긴다
  - `filterApples(inventory, (Apple a) -> a.getWeight() > 150)` : 무거운 사과만 남긴다
  - `filterApples(inventory, (Apple a) -> a.getWeight() < 80 || RED.equals(a.getColor()));` : or 연산자를 사용한 예제

한 번만 사용할 메서드는 따로 정의를 구현할 필요 없이 람다 식을 쓰면 되지만, 동작이 조금 복잡해져 몇 줄 이상으로 길어지면 익명 람다 보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직하다. **코드의 명확성이 우선시되어야 한다.**

# 5. 스트림

**컬렉션**에서는 반복 과정을 직접 처리해야 한다. 즉, for-each 루프를 이용해서 각 요소를 반복하면서 작업을 수행해야 하는데, 이런 방식의 반복을 **외부 반복(external iteration)** 이라고 한다.

```java
// 외부 반복
List<String> names = Arrays.asList("John", "Jane", "Jake", "Jill");

for(String name : names) {
  System.out.println(name);
}
```


반면 **스트림 API**를 이용하면 루프를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리되는데, 이와 같은 반복을 **내부 반복(internal iteration)** 이라고 한다.

```java
// 내부 반복
List<String> names = Arrays.asList("John", "Jane", "Jake", "Jill");

names.stream()
  .forEach(System.out.println);
```


스트림은 스트림 내의 요소를 쉽게 **병렬로 처리**할 수 있는 환경을 제공한다.

```java
import static java.util.stream.Collectors.toList;

List<Apple> heavyApples;

// 순차 처리 방식의 코드
heavyApples = inventory.stream().filter((Apple a) -> a.getWeight() > 150)
				.collect(toList());

// 병렬 처리 방식의 코드
heavyApples = intenvory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
					.collect(toList());
```


# 6. 디폴트 메서드와 자바 모듈

요즘에는 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있지만, 과거의 자바에서는 특별한 구조가 아닌 평범한 자바 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부였는데, 이 패키지의 인터페이스를 바꾸기는 매우 힘들었다.

예시. `List` 컬렉션의 `sort()` 메서드가 없어 모든 사람이 자기만의 `sort()` 를 따로 개발했는데, 자바 설계자가 `sort()` 인터페이스를 제공하려고 하면 두 `sort()` 메서드 간 충돌이 생긴다.

이를 위해 (하위 호환성을 위해) `디폴트 메서드` 가 등장했다.

인터페이스는 기능에 대한 선언만 가능하기 때문에, 실제 코드를 구현한 로직은 포함될 수 없다. 하지만 메소드 선언 시에 `default` 를 명시하게 되면 인터페이스 내부에서도 로직이 포함된 메소드를 선언할 수 있다.

여러분들이 만약 오픈 소스코드를 만들었다고 가정하자. 그 오픈소스가 엄청 유명해져서 전 세계 사람들이 다 사용하고 있는데, 인터페이스에 새로운 메소드를 만들어야 하는 상황이 발생했다. 자칫 잘못하면 내가 만든 오픈소스를 사용한 사람들은 전부 오류가 발생하고 수정을 해야 하는 일이 발생할 수도 있다. 이럴 때 사용하는 것이 바로 default 메소드다.

```java
interface MyInterface {
	default void sort() {
		// sort 알고리즘 생략
	}
}
```
